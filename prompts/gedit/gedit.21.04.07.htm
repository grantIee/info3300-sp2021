<html><head>
<title>INFO 3300 - April 7</title>
  <meta charset="utf-8">
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">

  <link rel="stylesheet" type="text/css" href="../css/normalize.css">
  <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="../css/custom-style.css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>

  text {
    font-family: sans-serif;
    font-variant: small-caps;
    font-size: small;
  }

  </style>
</head>

<body>
  <div class="container larger">
  <h3>Notes for April 7</h3>
  <p>Today we'll work with graph data once again. However, this time we will be placing emphasis on the edges between nodes rather than the structural relationship between nodes. For example, while it might be useful to spot character clusters in Les Mis√©rables, you need a different visual metaphor if you want to show more clearly the intensity of interactions *between* characters. Today we'll try out a chord diagram to expose the edges more saliently. While we won't get to in in class, there are also a wide variety of hierarchical visualizations available when you want to show nesting and structural details in a network.</p>
  <p>Today's dataset comes from a larger dataset of <a href="kaggle.com/mmmarchetti/game-of-thrones-network-analysis">character co-occurrences in the Game of Thrones book series</a>. I aggregated data into a final, sparse dataset of character relationships that show high co-occurrence (>50 interactions across 5 books). If you're a fan of the books and it makes you feel better, I promise I'll update the dataset for Winds of Winter <em>when</em> it comes out.</p>
  <p><a href="https://observablehq.com/@d3/chord-diagram">Here</a> is an Observable example of a chord diagram. <a href="http://bl.ocks.org/nbremer/94db779237655907b907">This one</a> attempts to add some interactivity.</p>
  <p>The <a href="https://github.com/d3/d3-chord">d3 chord library</a> has lots of helpful functions. We'll also be making use of the arc generator from <a href="https://github.com/d3/d3-shape">d3-shape</a>.</p>
  <p>To make a color palette for 20 different categories, I used the <a href="http://vrl.cs.brown.edu/color">Colorgorical</a> color optimization tool. <a href="https://projects.susielu.com/viz-palette">Viz Palette</a> is a decent way to test out different color scheme ideas.</p>
  
  
  
  
  
    
  <h5>HTML for today:</h5>

  <svg id="chord" height="850" width="850" style="background: #fff; margin-top:50px" >
  </svg>
  


  <h5>Code for today:</h5>
  <pre>
    <code id="display1" class="hljs javascript">
      <!--- autofilled --->
    </code>
  </pre>


  <script id="notes1">
  // See bottom of file for force-directed chart
  
  // Layer for drawing
  const width = d3.select("#chord").attr("width");
  const height = d3.select("#chord").attr("height");
  const chordChart = d3.select("#chord").append("g");
  
  const drawChord = async () => {
    
    // We'll use a color palette generated by this neat optimization tool: http://vrl.cs.brown.edu/color
    const colorPalette = ["#48bf8e", "#075c62", "#a1def0", "#5e2a96", 
                          "#e775cc", "#f3c5fa", "#9a76af", "#1c4585", 
                          "#479abc", "#94ea5b", "#1d6d1f", "#cddb9b", 
                          "#604020", "#d48f4d", "#f24219", "#8e1023", 
                          "#8c956d", "#2cf52b", "#ff0087", "#e9d737"]
    let colorScale = d3.scaleOrdinal().range(colorPalette);

    // Load GoT dataset
    const got = await d3.json("../datasets/thrones-cooccur.json");
    console.log(got);
    
    let nodes = got.nodes;
    let links = got.edges;
    
    // Make data we need
    let matrix = [];
    let connections = {};
    for(let i = 0; i < nodes.length; i++) {
      let row = [];
      for(let j = 0; j < nodes.length; j++) {
        row.push(0);
      }
      matrix.push(row);
      connections[i] = [i];
    }    
  
    links.forEach(d => {

      if(d.weight > 0) {
        matrix[d.sourceIndex][d.targetIndex] = d.weight;
        matrix[d.targetIndex][d.sourceIndex] = d.weight;

        connections[d.sourceIndex].push(d.targetIndex);
        connections[d.targetIndex].push(d.sourceIndex);

      }
    });

    let radius = (width/2.0) - 125;


    let chordGen = d3.chord()
                     .padAngle(0.04)
                     .sortSubgroups(d3.descending)
                     .sortChords(d3.descending);
    
    let arcGen = d3.arc()
                   .innerRadius(radius)
                   .outerRadius(radius + 20);



    let ribbonGen = d3.ribbon()
                      .radius(radius);


    let chords = chordGen(matrix);
    
    
    // Draw the diagram
    chordChart.attr("transform", `translate(${width/2.0}, ${height/2.0})`);
    
    let ringContainer = chordChart.append("g");
        
    let rings = ringContainer.selectAll("g.segment").data(chords.groups)
                             .join("g")
                             .attr("class", "segment");

    // for each of the g tags above create a path
    rings.append("path")
         .attr("fill", d => colorScale(nodes[d.index].Affiliation))
         .attr("stroke", d => colorScale(nodes[d.index].Affiliation))
         .attr("d", arcGen);
        
    let ribbonContainer = chordChart.append("g");

    let ribbons = ribbonContainer.selectAll("path.ribbon").data(chords)
                                 .join("path")
                                 .attr("fill-opacity", 0.5)
                                 .attr("stroke", "none")
                                 .attr("fill", d => colorScale(nodes[d.source.index].Affiliation))
                                 .attr("d", ribbonGen);
    
    // Adding in the labels

    //modify the data to make it fit by transforming
    chords.groups.forEach( d => {

      d.anchor = "start";
      let transform = '';

      let midpoint = (d.startAngle + d.endAngle) / 2.0
      let rotation = (midpoint) * (180 / Math.PI) - 90;
      transform = transform + `rotate(${rotation})`;
      transform = transform + `translate(${radius + 25}, 0)`;
      
      if(rotation > 90) { 
        transform = transform + 'rotate(180)';
        d.anchor = "end";
      }

      d.trans = transform;

    })

    rings.append("text")
         .text(d => nodes[d.index].Name)
         .attr("text-anchor", d => d.anchor)
         .attr("transform", d => d.trans)

    // Add interactions
    function restoreHighlights() {
      rings.attr("opacity", 1);
      ribbons.attr("opacity", 1);
    }
    
    function lowlightAll() {
      rings.attr("opacity", 0.2);
      ribbons.attr("opacity", 0.2);
    }

    function highlightRings(index) {
      let targetSegments = rings.filter(d => {
        return connections[index].includes(d.index);
      });
      targetSegments.attr("opacity", 1);
    }

    function highlightRibbons(index) {
      let targetRibbons = ribbons.filter(d => {
        return d.source.index === index || d.target.index === index;
      });
      targetRibbons.attr("opacity", 1);
    }

    rings.on("mouseout", restoreHighlights)
    rings.on("mouseover", function(event, d) {
      lowlightAll();
      highlightRings(d.index);
      highlightRibbons(d.index);
    })
    
    // Now let's see how you might make the arcs have nice gradients
    // defs that contain all the grads

    let getGradID = chord => `linkGrad-${chord.source.index}-${chord.target.index}`;

    var grads = d3.select("#chord").append("defs")
      .selectAll("linearGradient").data(chords)
      .join("linearGradient")
      .attr("id", getGradID)
      .attr("gradientUnits", "userSpaceOnUse")
      .attr("x1", d => radius * Math.cos((d.source.endAngle - d.source.startAngle) / 2 + d.source.startAngle - Math.PI / 2))
      .attr("y1", d => radius * Math.sin((d.source.endAngle - d.source.startAngle) / 2 + d.source.startAngle - Math.PI / 2))
      .attr("x2", d => radius * Math.cos((d.target.endAngle - d.target.startAngle) / 2 + d.target.startAngle - Math.PI / 2))
      .attr("y2", d => radius * Math.sin((d.target.endAngle - d.target.startAngle) / 2 + d.target.startAngle - Math.PI / 2))

    grads.append("stop")
      .attr("offset", "0%")
      .attr("stop-color", d => colorScale(nodes[d.source.index].Affiliation))

    grads.append("stop")
         .attr("offset", "100%")
         .attr("stop-color", d => colorScale( nodes[d.target.index].Affiliation))

    ribbons.attr("fill", d => `url(#${getGradID(d)})`);



    
    
    
    
    
    
  }
  drawChord();


  



  </script>








  <!--- calls the highlight library to fill the <pre> tag with code --->
  <script>
  document.getElementById("display1").innerText = document.getElementById("notes1").innerText;
  hljs.initHighlightingOnLoad();
  </script>


  </div>
</body>
</html>
